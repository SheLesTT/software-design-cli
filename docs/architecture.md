![cli](cli.png "CLI")

1. В функции `main` создаются `Input` и `Output` для `stdin` и `stdout`, а так же парсер (так сделано для упрощения тестирования), которые затем передаются в функцию `runCli`.
2. Функция `runCli` является главной функцией обработки. В цикле, пока не проставлен флаг о завершении работы, читает по строке из `Input` и передает ее вместе с парсером и `Output` в функцию `prcoessCommand`.
3. Функция `processCommand` сначала вызывает `Parcer::parse()`, чтобы парсер вычитал новые переменные, совершил подстановку переменных, а затем разбил строку на токены по пробелам с учетом строковых аргументов. Подстановка и парсинг объединены, т.к. для подстановки нам нужно найти аргументы (нужно учитывать, что в тексте может быть написано, например `echo '$var'`, и здесь не надо подставлять значение), а для разбиения на элементы нам нужна полная подстановка (пример с `$x$y = exit` в задании). Переменные окружения представляются в строковом виде и хранятся как пары ключ-значения внутри парсера.
4. После этого вызывается функция `splitIntoCommands`, которая разделяет токены по `"|"`. Для каждый группы токенов вызываем createCommand, которая по нулевому токену определяет название комманды. Если команда известная, то создаем объект нужного класса, куда в качестве параметров передаются остальные токены группы. Там же происходит их валидация в зависимости от специфики конкретной команды. Если же команда неизвестна, то создается объект `ExternalCommand`, которому в качестве команды передается нулевой токен, а в качестве аргументов все остальные токены группы. `ExitCommand` будет только проставлять глобальный флаг `isExit`, чтобы завершить обработку данных. Для добавления новой команды нужно создать соответствующий новый класс, а так же добавить поддержку в `createCommand`.
5. После того как мы получили все команды, вызывается функция `runCommands`. В ней для каждой последовательной пары команд создается `pipe(createPipe())`. Для первой команды передаем в качестве входа `DummyInput`, который будет кидать исключение при чтении. Это необходимо, т.к. каждая команда должна получать при запуске вход и выход, даже первая, у которой нет входа (может быть заменено в случае поддержки функциональности `cli < a.txt`). Для последней команды на выход подается изначальный `Output` созданный в `main`.
6. CLI пока что исполняется однопоточно, так как в общем случае представляет собой последовательный пайплайн, где очередная команда ждёт информации от предыдущей. В будущем имеется возможность для распараллеливания, например, следующим образом:
1) На CLI заводится тредпулл с N потоками.
2) Вводится абстракция `ExecutableTask`, принимающая на вход чанк с данными, команду и которую нужно над ними выполнить. Как вариант, такая таска может представлять собой корутину с асинхронным методом `.Get()`.
3) На этапе передачи `Output` одной команды в `Input` другой порежем данные на чанки, заворачиваем в `ExecutableTask` и отдаём массив задач в качестве `Input`в следующую команду, которая асинхронно ждёт выполнения таски в тред-пулле.